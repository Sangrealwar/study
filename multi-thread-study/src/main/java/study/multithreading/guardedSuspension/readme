

1.避免了样板式代码，虽然blocker参与者实现的挂起和唤醒用wait/notify或者lock。Conditon实现
但，里面涉及某些易错的技术点，将易错技术点封装后，可以减少出错的概率；
2.关注点分离
3.会增加jvm回收的负担，为了使GuardedAction的实例call能访问保护方法的参数，需要使用闭包回调；
这意味着每次保护方法调用时会产生新的GuardedAction实例（匿名对象），会增大jvm内存池Eden区域占用
4.会增加上下文切换，线程频繁暂挂和唤醒。


易错技术点：
1.内存可见性，锁泄露；
2.线程过早唤醒；
3.死锁


技术注意点：
1.blocker主要依靠条件锁 condition，操作和synchronize,wait,notify搭配默认的对象监视器一样
使用lock,await,signal锁定，等待和释放
2.在唤醒受保护的任务时，会先判断条件是否满足，避免存在多个条件，只满足了一个，被提前唤醒的情况