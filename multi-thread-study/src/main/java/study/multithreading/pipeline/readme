

Pipeline模式
并行和并发编程中，为了提高并发，我们需要将任务分解为若干较小的任务，但小任务之间有依赖关系。
Pipeline模式的每一个Pipe的输入元素可以看作是提交给该pipe的一个任务
这样前一个pipe实例的任务处理结果就是下一个pipe实例的输入任务。
从个体任务上看，pipeline模式对各个任务的处理是顺序的。
由于每个pipe实例都有其工作者线程处理，当pipe实例处理上游pipe实例提交的任务时，
上游实例已经在处理其接收到的其他任务。从整体任务上来看，pipeline对任务的处理又是并行的。

好处：
1.便于定位，子任务的处理涉及非线程安全或阻塞IO操作，可以考虑用单线程的编程，在Pipeline模式中，子任务采用单线程处理
只需要加入"用基于工作者线程的Pipe"即可；
2.每个Pipeline实例都是一个Pipe实例，因此我们不仅可以添加现有的实现，同时也可以扩展实现；

缺点:
各阶段使用的工作者线程和线程池，进出队列均有开销，因此适合处理大规模的任务。



1.基于线程池的Pipe
当pipeLine的深度比较大，或者Pipe实例需要多个工作者线程负责处理，为了避免创建过多的线程，可以考虑基于线程池的
Pipe。其本质是一个Pipeline实例中有多个Pipe实例作为相应线程池的客户端向线程池提交任务。
2.基于工作者线程的Pipe
通常的Pipe实现，该Pipe实例会接受输入元素到队列，由指定个数的工作者线程进行处理。